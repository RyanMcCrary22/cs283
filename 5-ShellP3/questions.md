1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

Each time an instance of the shell forks itself, the parent process recieves the child processes PID from the fork() syscall. Then, the parents uses that PID in a call to Waitpid(), which works the same way as wait, but instead of waiting for any of the parents children to change their state, it waits for the specific process specified by the given PID. If we did not use this call, and either just used wait() or did nothing to wait at all, a. our output could get very jumbled up becaue each process would continue to run at the same time as each other, therefore the shell prompt might print out before any of the children finished, and then their output would come behind the prompt where the users next command should be; and b. because of what I just said where processes would be running at the same time, our piped commands would not work correctly, because the piped commands expect the pervious comands output as input, therefore if the output from the previous command has not finished, the second command will not run as desired. 

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

Linux's file handling structure has a finite size, and therefore can only handle so many open files before it fills up which could result in processes not being able to run at all. When we open our pipes, each pipefd represents a file that was already open, so this file is actually taking up to file descriptor spots in the linux table and by closing it up we are using the space more efficiently. 

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

CD works using the chdir syscall(), which changes the directory of the process that calls it. Therefore, if we wrapped the syscall in another c program so that we could fork and exec it, the code would run correctly and the shell would think it executed, but we would actually have a bug because only the working directory of the child process would be changed not the running shell itself which is the behavior that we want.

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

To handle a dynamic amount of piped commands, we could make the command list hold a ** pointer to pointer to commands, instead of a fixed array of commands. This way, would count the number of piped commands each time a new command came in from the user and use malloc to allocate the necessary space, then free all commands again after they were executed. This would work, but I think it would come with a significant run-time trade off because malloc is a very time intensive operation.
